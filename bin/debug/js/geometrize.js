// Generated by Haxe 3.4.2 (git build master @ 890f8c7)
(function ($global) { "use strict";
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
var ID = function() { };
ID.__name__ = true;
var Main = function() {
	window.onload = $bind(this,this.onWindowLoaded);
};
Main.__name__ = true;
Main.getElement = function(id) {
	return window.document.getElementById(id);
};
Main.main = function() {
	var main = new Main();
};
Main.prototype = {
	onWindowLoaded: function() {
		this.maxShapeAdditionRate = 15.0;
		this.set_running(false);
		this.shapeTypes = geometrize__$ArraySet_ArraySet_$Impl_$.create([geometrize_shape_ShapeType.TRIANGLE]);
		this.shapeOpacity = 128;
		this.candidateShapesPerStep = 50;
		this.shapeMutationsPerStep = 100;
		this.shapeResults = [];
		this.targetImage = this.createDefaultBitmap();
		this.onTargetImageChanged();
		Main.circlesCheckbox.checked = true;
		var _gthis = this;
		noUiSlider.create(Main.shapeOpacitySlider,{ start : [this.shapeOpacity], connect : "lower", range : { "min" : [1,1], "max" : [255]}, pips : { mode : "range", density : 10}});
		this.createTooltips(Main.shapeOpacitySlider);
		Main.shapeOpacitySlider.noUiSlider.on("change",function(values,handle,rawValues) {
			_gthis.shapeOpacity = values[handle] | 0;
		});
		Main.shapeOpacitySlider.noUiSlider.on("update",function(values1,handle1,rawValues1) {
			_gthis.updateTooltips(Main.shapeOpacitySlider,handle1,values1[handle1] | 0);
		});
		noUiSlider.create(Main.randomShapesPerStepSlider,{ start : [this.candidateShapesPerStep], connect : "lower", range : { "min" : [10,1], "max" : [300]}, pips : { mode : "range", density : 10}});
		this.createTooltips(Main.randomShapesPerStepSlider);
		Main.randomShapesPerStepSlider.noUiSlider.on("change",function(values2,handle2,rawValues2) {
			_gthis.candidateShapesPerStep = values2[handle2] | 0;
		});
		Main.randomShapesPerStepSlider.noUiSlider.on("update",function(values3,handle3,rawValues3) {
			_gthis.updateTooltips(Main.randomShapesPerStepSlider,handle3,values3[handle3] | 0);
		});
		noUiSlider.create(Main.shapeMutationsPerStepSlider,{ start : [this.shapeMutationsPerStep], connect : "lower", range : { "min" : [10,1], "max" : [300]}, pips : { mode : "range", density : 10}});
		this.createTooltips(Main.shapeMutationsPerStepSlider);
		Main.shapeMutationsPerStepSlider.noUiSlider.on("change",function(values4,handle4,rawValues4) {
			_gthis.shapeMutationsPerStep = values4[handle4] | 0;
		});
		Main.shapeMutationsPerStepSlider.noUiSlider.on("update",function(values5,handle5,rawValues5) {
			_gthis.updateTooltips(Main.shapeMutationsPerStepSlider,handle5,values5[handle5] | 0);
		});
		var _gthis1 = this;
		Main.runPauseButton.addEventListener("click",function() {
			_gthis1.set_running(!_gthis1.running);
		},false);
		Main.openImageFileInput.addEventListener("change",function(e) {
			if(Main.openImageFileInput.files == null || Main.openImageFileInput.files.length == 0) {
				return;
			}
			var file = Main.openImageFileInput.files[0];
			var fileReader = new FileReader();
			fileReader.onload = function(e1) {
				var image = new Image();
				image.onload = function(e2) {
					var tmp = _gthis1.imageToCanvas(image);
					_gthis1.targetImage = _gthis1.canvasToBitmap(tmp);
					_gthis1.onTargetImageChanged();
				};
				image.src = fileReader.result;
			};
			fileReader.readAsDataURL(file);
			Main.openImageFileInput.files[0] = null;
		},false);
		Main.stepButton.addEventListener("click",function() {
			_gthis1.stepRunner();
		},false);
		Main.resetButton.addEventListener("click",function() {
			_gthis1.targetImage = _gthis1.targetImage;
			_gthis1.onTargetImageChanged();
		},false);
		Main.saveImageButton.addEventListener("click",function(e3) {
			var canvas = window.document.createElement("canvas");
			var tmp1 = _gthis1.runner.getImageData();
			_gthis1.drawBitmapToCanvas(tmp1,canvas);
			if(canvas.msToBlob != null) {
				var blob = canvas.msToBlob();
				var navigator = window.navigator;
				navigator.msSaveBlob(blob,"geometrized_image.png");
			} else {
				var data = canvas.toDataURL("image/png");
				Main.saveImageButton.download = "geometrized_image.png";
				Main.saveImageButton.href = data;
			}
		},false);
		Main.saveSvgButton.addEventListener("click",function(e4) {
			var data1 = geometrize_exporter_SvgExporter["export"](_gthis1.shapeResults,_gthis1.runner.model.width,_gthis1.runner.model.height);
			var svgBlob = new Blob([data1],{ type : "image/svg+xml;charset=utf-8"});
			var navigator1 = window.navigator;
			if(navigator1.msSaveBlob != null) {
				navigator1.msSaveBlob(svgBlob,"geometrized_svg.svg");
			} else {
				var svgUrl = URL.createObjectURL(svgBlob);
				Main.saveSvgButton.download = "geometrized_svg.svg";
				Main.saveSvgButton.href = svgUrl;
			}
		},false);
		var setShapeOption = function(option,enable) {
			if(enable) {
				geometrize__$ArraySet_ArraySet_$Impl_$.add(_gthis1.shapeTypes,option);
			} else {
				HxOverrides.remove(_gthis1.shapeTypes,option);
			}
		};
		Main.rectanglesCheckbox.addEventListener("click",function() {
			setShapeOption(geometrize_shape_ShapeType.RECTANGLE,Main.rectanglesCheckbox.checked);
		},false);
		Main.rotatedRectanglesCheckbox.addEventListener("click",function() {
			setShapeOption(geometrize_shape_ShapeType.ROTATED_RECTANGLE,Main.rotatedRectanglesCheckbox.checked);
		},false);
		Main.trianglesCheckbox.addEventListener("click",function() {
			setShapeOption(geometrize_shape_ShapeType.TRIANGLE,Main.trianglesCheckbox.checked);
		},false);
		Main.ellipsesCheckbox.addEventListener("click",function() {
			setShapeOption(geometrize_shape_ShapeType.ELLIPSE,Main.ellipsesCheckbox.checked);
		},false);
		Main.rotatedEllipsesCheckbox.addEventListener("click",function() {
			setShapeOption(geometrize_shape_ShapeType.ROTATED_ELLIPSE,Main.rotatedEllipsesCheckbox.checked);
		},false);
		Main.circlesCheckbox.addEventListener("click",function() {
			setShapeOption(geometrize_shape_ShapeType.CIRCLE,Main.circlesCheckbox.checked);
		},false);
		Main.linesCheckbox.addEventListener("click",function() {
			setShapeOption(geometrize_shape_ShapeType.LINE,Main.linesCheckbox.checked);
		},false);
		this.animate();
	}
	,animate: function() {
		var _gthis = this;
		if(this.running) {
			this.stepRunner();
		}
		var nextFrameDelay = 1.0 / this.maxShapeAdditionRate * 1000.0 | 0;
		window.setTimeout(function() {
			_gthis.animate();
		},nextFrameDelay);
	}
	,stepRunner: function() {
		this.appendShapeResults(this.runner.step(new geometrize_runner_ImageRunnerOptions(this.shapeTypes.length == 0 ? [geometrize_shape_ShapeType.TRIANGLE] : geometrize__$ArraySet_ArraySet_$Impl_$.toArray(this.shapeTypes),this.shapeOpacity,this.candidateShapesPerStep,this.shapeMutationsPerStep)));
		this.drawBitmapToCanvas(this.runner.getImageData(),Main.currentImageCanvas);
	}
	,constructRunnerOptions: function() {
		return new geometrize_runner_ImageRunnerOptions(this.shapeTypes.length == 0 ? [geometrize_shape_ShapeType.TRIANGLE] : geometrize__$ArraySet_ArraySet_$Impl_$.toArray(this.shapeTypes),this.shapeOpacity,this.candidateShapesPerStep,this.shapeMutationsPerStep);
	}
	,init: function() {
		this.maxShapeAdditionRate = 15.0;
		this.set_running(false);
		this.shapeTypes = geometrize__$ArraySet_ArraySet_$Impl_$.create([geometrize_shape_ShapeType.TRIANGLE]);
		this.shapeOpacity = 128;
		this.candidateShapesPerStep = 50;
		this.shapeMutationsPerStep = 100;
		this.shapeResults = [];
		this.targetImage = this.createDefaultBitmap();
		this.onTargetImageChanged();
		Main.circlesCheckbox.checked = true;
	}
	,createSliders: function() {
		var _gthis = this;
		noUiSlider.create(Main.shapeOpacitySlider,{ start : [this.shapeOpacity], connect : "lower", range : { "min" : [1,1], "max" : [255]}, pips : { mode : "range", density : 10}});
		this.createTooltips(Main.shapeOpacitySlider);
		Main.shapeOpacitySlider.noUiSlider.on("change",function(values,handle,rawValues) {
			_gthis.shapeOpacity = values[handle] | 0;
		});
		Main.shapeOpacitySlider.noUiSlider.on("update",function(values1,handle1,rawValues1) {
			_gthis.updateTooltips(Main.shapeOpacitySlider,handle1,values1[handle1] | 0);
		});
		noUiSlider.create(Main.randomShapesPerStepSlider,{ start : [this.candidateShapesPerStep], connect : "lower", range : { "min" : [10,1], "max" : [300]}, pips : { mode : "range", density : 10}});
		this.createTooltips(Main.randomShapesPerStepSlider);
		Main.randomShapesPerStepSlider.noUiSlider.on("change",function(values2,handle2,rawValues2) {
			_gthis.candidateShapesPerStep = values2[handle2] | 0;
		});
		Main.randomShapesPerStepSlider.noUiSlider.on("update",function(values3,handle3,rawValues3) {
			_gthis.updateTooltips(Main.randomShapesPerStepSlider,handle3,values3[handle3] | 0);
		});
		noUiSlider.create(Main.shapeMutationsPerStepSlider,{ start : [this.shapeMutationsPerStep], connect : "lower", range : { "min" : [10,1], "max" : [300]}, pips : { mode : "range", density : 10}});
		this.createTooltips(Main.shapeMutationsPerStepSlider);
		Main.shapeMutationsPerStepSlider.noUiSlider.on("change",function(values4,handle4,rawValues4) {
			_gthis.shapeMutationsPerStep = values4[handle4] | 0;
		});
		Main.shapeMutationsPerStepSlider.noUiSlider.on("update",function(values5,handle5,rawValues5) {
			_gthis.updateTooltips(Main.shapeMutationsPerStepSlider,handle5,values5[handle5] | 0);
		});
	}
	,addEventListeners: function() {
		var _gthis = this;
		Main.runPauseButton.addEventListener("click",function() {
			_gthis.set_running(!_gthis.running);
		},false);
		Main.openImageFileInput.addEventListener("change",function(e) {
			if(Main.openImageFileInput.files == null || Main.openImageFileInput.files.length == 0) {
				return;
			}
			var file = Main.openImageFileInput.files[0];
			var fileReader = new FileReader();
			fileReader.onload = function(e1) {
				var image = new Image();
				image.onload = function(e2) {
					var tmp = _gthis.imageToCanvas(image);
					_gthis.targetImage = _gthis.canvasToBitmap(tmp);
					_gthis.onTargetImageChanged();
				};
				image.src = fileReader.result;
			};
			fileReader.readAsDataURL(file);
			Main.openImageFileInput.files[0] = null;
		},false);
		Main.stepButton.addEventListener("click",function() {
			_gthis.stepRunner();
		},false);
		Main.resetButton.addEventListener("click",function() {
			_gthis.targetImage = _gthis.targetImage;
			_gthis.onTargetImageChanged();
		},false);
		Main.saveImageButton.addEventListener("click",function(e3) {
			var canvas = window.document.createElement("canvas");
			var tmp1 = _gthis.runner.getImageData();
			_gthis.drawBitmapToCanvas(tmp1,canvas);
			if(canvas.msToBlob != null) {
				var blob = canvas.msToBlob();
				var navigator = window.navigator;
				navigator.msSaveBlob(blob,"geometrized_image.png");
			} else {
				var data = canvas.toDataURL("image/png");
				Main.saveImageButton.download = "geometrized_image.png";
				Main.saveImageButton.href = data;
			}
		},false);
		Main.saveSvgButton.addEventListener("click",function(e4) {
			var data1 = geometrize_exporter_SvgExporter["export"](_gthis.shapeResults,_gthis.runner.model.width,_gthis.runner.model.height);
			var svgBlob = new Blob([data1],{ type : "image/svg+xml;charset=utf-8"});
			var navigator1 = window.navigator;
			if(navigator1.msSaveBlob != null) {
				navigator1.msSaveBlob(svgBlob,"geometrized_svg.svg");
			} else {
				var svgUrl = URL.createObjectURL(svgBlob);
				Main.saveSvgButton.download = "geometrized_svg.svg";
				Main.saveSvgButton.href = svgUrl;
			}
		},false);
		var setShapeOption = function(option,enable) {
			if(enable) {
				geometrize__$ArraySet_ArraySet_$Impl_$.add(_gthis.shapeTypes,option);
			} else {
				HxOverrides.remove(_gthis.shapeTypes,option);
			}
		};
		Main.rectanglesCheckbox.addEventListener("click",function() {
			setShapeOption(geometrize_shape_ShapeType.RECTANGLE,Main.rectanglesCheckbox.checked);
		},false);
		Main.rotatedRectanglesCheckbox.addEventListener("click",function() {
			setShapeOption(geometrize_shape_ShapeType.ROTATED_RECTANGLE,Main.rotatedRectanglesCheckbox.checked);
		},false);
		Main.trianglesCheckbox.addEventListener("click",function() {
			setShapeOption(geometrize_shape_ShapeType.TRIANGLE,Main.trianglesCheckbox.checked);
		},false);
		Main.ellipsesCheckbox.addEventListener("click",function() {
			setShapeOption(geometrize_shape_ShapeType.ELLIPSE,Main.ellipsesCheckbox.checked);
		},false);
		Main.rotatedEllipsesCheckbox.addEventListener("click",function() {
			setShapeOption(geometrize_shape_ShapeType.ROTATED_ELLIPSE,Main.rotatedEllipsesCheckbox.checked);
		},false);
		Main.circlesCheckbox.addEventListener("click",function() {
			setShapeOption(geometrize_shape_ShapeType.CIRCLE,Main.circlesCheckbox.checked);
		},false);
		Main.linesCheckbox.addEventListener("click",function() {
			setShapeOption(geometrize_shape_ShapeType.LINE,Main.linesCheckbox.checked);
		},false);
	}
	,createTooltips: function(slider) {
		var tipHandles = slider.getElementsByClassName("noUi-handle");
		var _g1 = 0;
		var _g = tipHandles.length;
		while(_g1 < _g) {
			var i = _g1++;
			var div = window.document.createElement("div");
			div.className += "tooltip";
			tipHandles[i].appendChild(div);
			this.updateTooltips(slider,i,0);
		}
	}
	,updateTooltips: function(slider,handleIdx,value) {
		var tipHandles = slider.getElementsByClassName("noUi-handle");
		tipHandles[handleIdx].innerHTML = "<span class='tooltip'>" + (value == null ? "null" : "" + value) + "</span>";
	}
	,appendEventText: function(message) {
		if(Main.eventLogElement.value == null) {
			Main.eventLogElement.value = "";
		}
		Main.eventLogElement.value += message + "\n";
	}
	,clearEventText: function() {
		Main.eventLogElement.value = "";
	}
	,appendSvgText: function(message) {
		if(Main.svgTextElement.value == null) {
			Main.svgTextElement.value = "";
		}
		Main.svgTextElement.value += message + "\n";
	}
	,clearSvgText: function() {
		Main.svgTextElement.value = "";
	}
	,appendShapeResults: function(results) {
		this.shapeResults = this.shapeResults.concat(results);
		var _g = 0;
		while(_g < results.length) {
			var result = results[_g];
			++_g;
			var shape = result.shape;
			this.appendEventText("Added shape " + this.shapeResults.length + ": " + Std.string(shape.getType()) + " with data " + Std.string(shape.getRawShapeData()));
			this.appendSvgText(geometrize_exporter_SvgExporter.exportShape(result));
		}
		this.setSvgElement(geometrize_exporter_SvgExporter["export"](this.shapeResults,this.runner.model.width,this.runner.model.height));
	}
	,drawBitmapToCanvas: function(bitmap,canvas) {
		canvas.width = bitmap.width;
		canvas.height = bitmap.height;
		var context = canvas.getContext("2d",null);
		var imageData = context.createImageData(canvas.width,canvas.height);
		var bytes = new haxe_io_Bytes(new ArrayBuffer(bitmap.data.length * 4));
		var i = 0;
		while(i < bitmap.data.length) {
			var idx = i * 4;
			bytes.b[idx] = bitmap.data[i] >>> 24 & 255 & 255;
			bytes.b[idx + 1] = bitmap.data[i] >>> 16 & 255 & 255;
			bytes.b[idx + 2] = bitmap.data[i] >>> 8 & 255 & 255;
			bytes.b[idx + 3] = bitmap.data[i] & 255 & 255;
			++i;
		}
		var bytesData = bytes;
		var _g1 = 0;
		var _g = bytesData.length;
		while(_g1 < _g) {
			var i1 = _g1++;
			imageData.data[i1] = bytesData.b[i1];
		}
		context.putImageData(imageData,0,0);
		return canvas;
	}
	,canvasToBitmap: function(canvas) {
		var context = canvas.getContext("2d",null);
		var imageData = context.getImageData(0,0,canvas.width,canvas.height);
		var bytesData = new haxe_io_Bytes(new ArrayBuffer(imageData.data.length));
		var _g1 = 0;
		var _g = bytesData.length;
		while(_g1 < _g) {
			var i = _g1++;
			bytesData.b[i] = imageData.data[i] & 255;
		}
		var w = canvas.width;
		var h = canvas.height;
		var bitmap = new geometrize_bitmap_Bitmap();
		if(!(bytesData != null)) {
			throw new js__$Boot_HaxeError("FAIL: bytes != null");
		}
		var actual = bytesData.length;
		var expected = w * h * 4;
		if(actual != expected) {
			throw new js__$Boot_HaxeError("FAIL: values are not equal (expected: " + expected + ", actual: " + actual + ")");
		}
		bitmap.width = w;
		bitmap.height = h;
		var length = bytesData.length / 4 | 0;
		var this1 = new Array(length);
		bitmap.data = this1;
		var i1 = 0;
		var x = 0;
		while(i1 < bytesData.length) {
			var red = bytesData.b[i1];
			var green = bytesData.b[i1 + 1];
			var blue = bytesData.b[i1 + 2];
			var alpha = bytesData.b[i1 + 3];
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			bitmap.data[x] = ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);
			i1 += 4;
			++x;
		}
		var bitmap1 = bitmap;
		return bitmap1;
	}
	,imageToCanvas: function(image) {
		var canvas = window.document.createElement("canvas");
		canvas.width = image.width;
		canvas.height = image.height;
		var context = canvas.getContext("2d",null);
		context.drawImage(image,0,0);
		return canvas;
	}
	,setSvgElement: function(svgCode) {
		Main.currentSvgContainer.innerHTML = svgCode;
	}
	,createDefaultBitmap: function() {
		return this.canvasToBitmap(this.imageToCanvas(Main.seagullImageElement));
	}
	,onTargetImageChanged: function() {
		if(this.runner == null) {
			this.appendEventText("Initializing image runner and setting default bitmap...");
		} else {
			this.appendEventText("Resetting current image and removing shapes...");
		}
		var backgroundColor = geometrize_Util.getAverageImageColor(this.targetImage);
		this.runner = new geometrize_runner_ImageRunner(this.targetImage,backgroundColor);
		this.drawBitmapToCanvas(this.runner.getImageData(),Main.currentImageCanvas);
		this.clearEventText();
		this.clearSvgText();
		this.shapeResults = [];
		var backgroundRect = new geometrize_shape_Rectangle(this.targetImage.width,this.targetImage.height);
		backgroundRect.x1 = 0;
		backgroundRect.y1 = 0;
		backgroundRect.x2 = this.targetImage.width - 1;
		backgroundRect.y2 = this.targetImage.height - 1;
		this.appendShapeResults([{ score : 0.0, color : backgroundColor, shape : backgroundRect}]);
	}
	,set_running: function(running) {
		Main.runPauseButton.innerHTML = running ? "<h2>Pause</h2>" : "<h2>Run</h2>";
		return this.running = running;
	}
	,__class__: Main
};
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.random = function(x) {
	if(x <= 0) {
		return 0;
	} else {
		return Math.floor(Math.random() * x);
	}
};
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
var _$UInt_UInt_$Impl_$ = {};
_$UInt_UInt_$Impl_$.__name__ = true;
_$UInt_UInt_$Impl_$.toFloat = function(this1) {
	var $int = this1;
	if($int < 0) {
		return 4294967296.0 + $int;
	} else {
		return $int + 0.0;
	}
};
var geometrize__$ArraySet_ArraySet_$Impl_$ = {};
geometrize__$ArraySet_ArraySet_$Impl_$.__name__ = true;
geometrize__$ArraySet_ArraySet_$Impl_$.create = function(array) {
	if(array == null) {
		var this1 = [];
		return this1;
	}
	return geometrize__$ArraySet_ArraySet_$Impl_$.toSet(array);
};
geometrize__$ArraySet_ArraySet_$Impl_$.intersection = function(this1,set) {
	var result = [];
	var _g = 0;
	while(_g < this1.length) {
		var element = this1[_g];
		++_g;
		if(geometrize__$ArraySet_ArraySet_$Impl_$.contains(set,element)) {
			result.push(element);
		}
	}
	var this2 = result;
	return this2;
};
geometrize__$ArraySet_ArraySet_$Impl_$.union = function(this1,set) {
	return geometrize__$ArraySet_ArraySet_$Impl_$.toSet(this1.concat(geometrize__$ArraySet_ArraySet_$Impl_$.toArray(set)));
};
geometrize__$ArraySet_ArraySet_$Impl_$.unionArray = function(this1,array) {
	return geometrize__$ArraySet_ArraySet_$Impl_$.toSet(this1.concat(array));
};
geometrize__$ArraySet_ArraySet_$Impl_$.difference = function(this1,set) {
	var this2 = this1.slice();
	var result = this2;
	var element = HxOverrides.iter(set);
	while(element.hasNext()) {
		var element1 = element.next();
		HxOverrides.remove(result,element1);
	}
	var this3 = geometrize__$ArraySet_ArraySet_$Impl_$.toArray(result);
	return this3;
};
geometrize__$ArraySet_ArraySet_$Impl_$.add = function(this1,element) {
	if(!(element != null)) {
		throw new js__$Boot_HaxeError("FAIL: element != null");
	}
	if(geometrize__$ArraySet_ArraySet_$Impl_$.contains(this1,element)) {
		return false;
	}
	this1.push(element);
	return true;
};
geometrize__$ArraySet_ArraySet_$Impl_$.contains = function(this1,element) {
	var _g = 0;
	while(_g < this1.length) {
		var i = this1[_g];
		++_g;
		if(i == element) {
			return true;
		}
	}
	return false;
};
geometrize__$ArraySet_ArraySet_$Impl_$.copy = function(this1) {
	var this2 = this1.slice();
	return this2;
};
geometrize__$ArraySet_ArraySet_$Impl_$.slice = function(this1,position,end) {
	var this2 = this1.slice(position,end);
	return this2;
};
geometrize__$ArraySet_ArraySet_$Impl_$.splice = function(this1,position,length) {
	var this2 = this1.splice(position,length);
	return this2;
};
geometrize__$ArraySet_ArraySet_$Impl_$.toArray = function(this1) {
	return this1.slice();
};
geometrize__$ArraySet_ArraySet_$Impl_$.toSet = function(array) {
	var this1 = [];
	var set = this1;
	var _g = 0;
	while(_g < array.length) {
		var v = array[_g];
		++_g;
		geometrize__$ArraySet_ArraySet_$Impl_$.add(set,v);
	}
	return set;
};
geometrize__$ArraySet_ArraySet_$Impl_$._new = function(array) {
	var this1 = array;
	return this1;
};
var geometrize_Core = function() { };
geometrize_Core.__name__ = true;
geometrize_Core.computeColor = function(target,current,lines,alpha) {
	if(!(target != null)) {
		throw new js__$Boot_HaxeError("FAIL: target != null");
	}
	if(!(current != null)) {
		throw new js__$Boot_HaxeError("FAIL: current != null");
	}
	if(!(lines != null)) {
		throw new js__$Boot_HaxeError("FAIL: lines != null");
	}
	if(!(alpha >= 0)) {
		throw new js__$Boot_HaxeError("FAIL: alpha >= 0");
	}
	var totalRed = 0;
	var totalGreen = 0;
	var totalBlue = 0;
	var count = 0;
	var f = 65535 / alpha;
	var a = f | 0;
	var _g = 0;
	while(_g < lines.length) {
		var line = lines[_g];
		++_g;
		var y = line.y;
		var _g2 = line.x1;
		var _g1 = line.x2 + 1;
		while(_g2 < _g1) {
			var x = _g2++;
			var t = target.data[target.width * y + x];
			var c = current.data[current.width * y + x];
			totalRed += ((t >>> 24 & 255) - (c >>> 24 & 255)) * a + (c >>> 24 & 255) * 257;
			totalGreen += ((t >>> 16 & 255) - (c >>> 16 & 255)) * a + (c >>> 16 & 255) * 257;
			totalBlue += ((t >>> 8 & 255) - (c >>> 8 & 255)) * a + (c >>> 8 & 255) * 257;
			++count;
		}
	}
	if(count == 0) {
		return 0;
	}
	var value = (totalRed / count | 0) >> 8;
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	var r = value < 0 ? 0 : value > 255 ? 255 : value;
	var value1 = (totalGreen / count | 0) >> 8;
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	var g = value1 < 0 ? 0 : value1 > 255 ? 255 : value1;
	var value2 = (totalBlue / count | 0) >> 8;
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	var b = value2 < 0 ? 0 : value2 > 255 ? 255 : value2;
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	return ((r < 0 ? 0 : r > 255 ? 255 : r) << 24) + ((g < 0 ? 0 : g > 255 ? 255 : g) << 16) + ((b < 0 ? 0 : b > 255 ? 255 : b) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);
};
geometrize_Core.differenceFull = function(first,second) {
	if(!(first != null)) {
		throw new js__$Boot_HaxeError("FAIL: first != null");
	}
	if(!(second != null)) {
		throw new js__$Boot_HaxeError("FAIL: second != null");
	}
	var actual = first.width;
	var expected = second.width;
	if(actual != expected) {
		throw new js__$Boot_HaxeError("FAIL: values are not equal (expected: " + expected + ", actual: " + actual + ")");
	}
	var actual1 = first.height;
	var expected1 = second.height;
	if(actual1 != expected1) {
		throw new js__$Boot_HaxeError("FAIL: values are not equal (expected: " + expected1 + ", actual: " + actual1 + ")");
	}
	var total = 0;
	var width = first.width;
	var height = first.height;
	var _g1 = 0;
	var _g = height;
	while(_g1 < _g) {
		var y = _g1++;
		var _g3 = 0;
		var _g2 = width;
		while(_g3 < _g2) {
			var x = _g3++;
			var f = first.data[first.width * y + x];
			var s = second.data[second.width * y + x];
			var dr = (f >>> 24 & 255) - (s >>> 24 & 255);
			var dg = (f >>> 16 & 255) - (s >>> 16 & 255);
			var db = (f >>> 8 & 255) - (s >>> 8 & 255);
			var da = (f & 255) - (s & 255);
			total += dr * dr + dg * dg + db * db + da * da;
		}
	}
	return Math.sqrt(total / (width * height * 4.0)) / 255;
};
geometrize_Core.differencePartial = function(target,before,after,score,lines) {
	if(!(target != null)) {
		throw new js__$Boot_HaxeError("FAIL: target != null");
	}
	if(!(before != null)) {
		throw new js__$Boot_HaxeError("FAIL: before != null");
	}
	if(!(after != null)) {
		throw new js__$Boot_HaxeError("FAIL: after != null");
	}
	if(!(lines != null)) {
		throw new js__$Boot_HaxeError("FAIL: lines != null");
	}
	var width = target.width;
	var height = target.height;
	var rgbaCount = width * height * 4;
	var total = Math.pow(score * 255,2) * rgbaCount;
	var _g = 0;
	while(_g < lines.length) {
		var line = lines[_g];
		++_g;
		var y = line.y;
		var _g2 = line.x1;
		var _g1 = line.x2 + 1;
		while(_g2 < _g1) {
			var x = _g2++;
			var t = target.data[target.width * y + x];
			var b = before.data[before.width * y + x];
			var a = after.data[after.width * y + x];
			var dtbr = (t >>> 24 & 255) - (b >>> 24 & 255);
			var dtbg = (t >>> 16 & 255) - (b >>> 16 & 255);
			var dtbb = (t >>> 8 & 255) - (b >>> 8 & 255);
			var dtba = (t & 255) - (b & 255);
			var dtar = (t >>> 24 & 255) - (a >>> 24 & 255);
			var dtag = (t >>> 16 & 255) - (a >>> 16 & 255);
			var dtab = (t >>> 8 & 255) - (a >>> 8 & 255);
			var dtaa = (t & 255) - (a & 255);
			total -= dtbr * dtbr + dtbg * dtbg + dtbb * dtbb + dtba * dtba;
			total += dtar * dtar + dtag * dtag + dtab * dtab + dtaa * dtaa;
		}
	}
	return Math.sqrt(total / rgbaCount) / 255;
};
geometrize_Core.bestRandomState = function(shapes,alpha,n,target,current,buffer,lastScore) {
	var bestEnergy = 0;
	var bestState = null;
	var _g1 = 0;
	var _g = n;
	while(_g1 < _g) {
		var i = _g1++;
		var state = new geometrize_State(geometrize_shape_ShapeFactory.randomShapeOf(shapes,current.width,current.height),alpha,target,current,buffer);
		var energy = state.energy(lastScore);
		if(i == 0 || energy < bestEnergy) {
			bestEnergy = energy;
			bestState = state;
		}
	}
	return bestState;
};
geometrize_Core.bestHillClimbState = function(shapes,alpha,n,age,target,current,buffer,lastScore) {
	var state = geometrize_Core.bestRandomState(shapes,alpha,n,target,current,buffer,lastScore);
	state = geometrize_Core.hillClimb(state,age,lastScore);
	return state;
};
geometrize_Core.hillClimb = function(state,maxAge,lastScore) {
	if(!(state != null)) {
		throw new js__$Boot_HaxeError("FAIL: state != null");
	}
	if(!(maxAge >= 0)) {
		throw new js__$Boot_HaxeError("FAIL: maxAge >= 0");
	}
	var state1 = state.clone();
	var bestState = state1.clone();
	var bestEnergy = state1.energy(lastScore);
	var age = 0;
	while(age < maxAge) {
		var undo = state1.mutate();
		var energy = state1.energy(lastScore);
		if(energy >= bestEnergy) {
			state1 = undo;
		} else {
			bestEnergy = energy;
			bestState = state1.clone();
			age = -1;
		}
		++age;
	}
	return bestState;
};
geometrize_Core.energy = function(shape,alpha,target,current,buffer,score) {
	if(!(shape != null)) {
		throw new js__$Boot_HaxeError("FAIL: shape != null");
	}
	if(!(target != null)) {
		throw new js__$Boot_HaxeError("FAIL: target != null");
	}
	if(!(current != null)) {
		throw new js__$Boot_HaxeError("FAIL: current != null");
	}
	if(!(buffer != null)) {
		throw new js__$Boot_HaxeError("FAIL: buffer != null");
	}
	var lines = shape.rasterize();
	var color = geometrize_Core.computeColor(target,current,lines,alpha);
	geometrize_rasterizer_Rasterizer.copyLines(buffer,current,lines);
	geometrize_rasterizer_Rasterizer.drawLines(buffer,color,lines);
	return geometrize_Core.differencePartial(target,current,buffer,score,lines);
};
var geometrize_Model = function(target,backgroundColor) {
	if(!(target != null)) {
		throw new js__$Boot_HaxeError("FAIL: target != null");
	}
	this.width = target.width;
	this.height = target.height;
	this.target = target;
	var w = target.width;
	var h = target.height;
	var bitmap = new geometrize_bitmap_Bitmap();
	bitmap.width = w;
	bitmap.height = h;
	var this1 = new Array(w * h);
	bitmap.data = this1;
	var i = 0;
	while(i < bitmap.data.length) {
		bitmap.data[i] = backgroundColor;
		++i;
	}
	this.current = bitmap;
	var w1 = target.width;
	var h1 = target.height;
	var bitmap1 = new geometrize_bitmap_Bitmap();
	bitmap1.width = w1;
	bitmap1.height = h1;
	var this2 = new Array(w1 * h1);
	bitmap1.data = this2;
	var i1 = 0;
	while(i1 < bitmap1.data.length) {
		bitmap1.data[i1] = backgroundColor;
		++i1;
	}
	this.buffer = bitmap1;
	this.score = geometrize_Core.differenceFull(target,this.current);
};
geometrize_Model.__name__ = true;
geometrize_Model.prototype = {
	step: function(shapeTypes,alpha,n,age) {
		var state = geometrize_Core.bestHillClimbState(shapeTypes,alpha,n,age,this.target,this.current,this.buffer,this.score);
		var results = [this.addShape(state.shape,state.alpha)];
		return results;
	}
	,addShape: function(shape,alpha) {
		if(!(shape != null)) {
			throw new js__$Boot_HaxeError("FAIL: shape != null");
		}
		var _this = this.current;
		var bitmap = new geometrize_bitmap_Bitmap();
		bitmap.width = _this.width;
		bitmap.height = _this.height;
		var length = _this.data.length;
		var this1 = new Array(length);
		bitmap.data = this1;
		var _g1 = 0;
		var _g = _this.data.length;
		while(_g1 < _g) {
			var i = _g1++;
			bitmap.data[i] = _this.data[i];
		}
		var before = bitmap;
		var lines = shape.rasterize();
		var color = geometrize_Core.computeColor(this.target,this.current,lines,alpha);
		geometrize_rasterizer_Rasterizer.drawLines(this.current,color,lines);
		this.score = geometrize_Core.differencePartial(this.target,before,this.current,this.score,lines);
		var result = { score : this.score, color : color, shape : shape};
		return result;
	}
	,__class__: geometrize_Model
};
var geometrize_State = function(shape,alpha,target,current,buffer) {
	if(!(shape != null)) {
		throw new js__$Boot_HaxeError("FAIL: shape != null");
	}
	this.shape = shape;
	this.alpha = alpha;
	this.score = -1;
	this.target = target;
	this.current = current;
	this.buffer = buffer;
};
geometrize_State.__name__ = true;
geometrize_State.prototype = {
	energy: function(lastScore) {
		if(this.score < 0) {
			this.score = geometrize_Core.energy(this.shape,this.alpha,this.target,this.current,this.buffer,lastScore);
		}
		return this.score;
	}
	,mutate: function() {
		var oldState = this.clone();
		this.shape.mutate();
		return oldState;
	}
	,clone: function() {
		return new geometrize_State(this.shape.clone(),this.alpha,this.target,this.current,this.buffer);
	}
	,__class__: geometrize_State
};
var geometrize_Util = function() { };
geometrize_Util.__name__ = true;
geometrize_Util.getAverageImageColor = function(image) {
	if(!(image != null)) {
		throw new js__$Boot_HaxeError("FAIL: image != null");
	}
	var totalRed = 0;
	var totalGreen = 0;
	var totalBlue = 0;
	var _g1 = 0;
	var _g = image.width;
	while(_g1 < _g) {
		var x = _g1++;
		var _g3 = 0;
		var _g2 = image.height;
		while(_g3 < _g2) {
			var y = _g3++;
			var pixel = image.data[image.width * y + x];
			totalRed += pixel >>> 24 & 255;
			totalGreen += pixel >>> 16 & 255;
			totalBlue += pixel >>> 8 & 255;
		}
	}
	var size = image.width * image.height;
	var red = totalRed / size | 0;
	var green = totalGreen / size | 0;
	var blue = totalBlue / size | 0;
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	return ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + 255;
};
geometrize_Util.clamp = function(value,min,max) {
	if(!(min <= max)) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	if(value < min) {
		return min;
	} else if(value > max) {
		return max;
	} else {
		return value;
	}
};
geometrize_Util.min = function(first,second) {
	if(first < second) {
		return first;
	} else {
		return second;
	}
};
geometrize_Util.max = function(first,second) {
	if(first > second) {
		return first;
	} else {
		return second;
	}
};
geometrize_Util.toRadians = function(degrees) {
	return degrees * Math.PI / 180;
};
geometrize_Util.toDegrees = function(radians) {
	return radians * 180 / Math.PI;
};
geometrize_Util.random = function(lower,upper) {
	if(!(lower <= upper)) {
		throw new js__$Boot_HaxeError("FAIL: lower <= upper");
	}
	return lower + Math.floor((upper - lower + 1) * Math.random());
};
geometrize_Util.randomArrayItem = function(a) {
	if(!(a != null && a.length > 0)) {
		throw new js__$Boot_HaxeError("FAIL: a != null && a.length > 0");
	}
	var upper = a.length - 1;
	if(!(0 <= upper)) {
		throw new js__$Boot_HaxeError("FAIL: lower <= upper");
	}
	return a[Math.floor((upper + 1) * Math.random())];
};
geometrize_Util.minMaxElements = function(a) {
	if(a == null || a.length == 0) {
		return { min : 0, max : 0};
	}
	var min = a[0];
	var max = a[0];
	var _g = 0;
	while(_g < a.length) {
		var value = a[_g];
		++_g;
		if(min > value) {
			min = value;
		}
		if(max < value) {
			max = value;
		}
	}
	return { min : min, max : max};
};
geometrize_Util.abs = function(value) {
	if(value < 0) {
		return -value;
	}
	return value;
};
var geometrize_bitmap_Bitmap = function() {
};
geometrize_bitmap_Bitmap.__name__ = true;
geometrize_bitmap_Bitmap.create = function(w,h,color) {
	var bitmap = new geometrize_bitmap_Bitmap();
	bitmap.width = w;
	bitmap.height = h;
	var this1 = new Array(w * h);
	bitmap.data = this1;
	var i = 0;
	while(i < bitmap.data.length) {
		bitmap.data[i] = color;
		++i;
	}
	return bitmap;
};
geometrize_bitmap_Bitmap.createFromBytes = function(w,h,bytes) {
	var bitmap = new geometrize_bitmap_Bitmap();
	if(!(bytes != null)) {
		throw new js__$Boot_HaxeError("FAIL: bytes != null");
	}
	var actual = bytes.length;
	var expected = w * h * 4;
	if(actual != expected) {
		throw new js__$Boot_HaxeError("FAIL: values are not equal (expected: " + expected + ", actual: " + actual + ")");
	}
	bitmap.width = w;
	bitmap.height = h;
	var length = bytes.length / 4 | 0;
	var this1 = new Array(length);
	bitmap.data = this1;
	var i = 0;
	var x = 0;
	while(i < bytes.length) {
		var red = bytes.b[i];
		var green = bytes.b[i + 1];
		var blue = bytes.b[i + 2];
		var alpha = bytes.b[i + 3];
		if(!true) {
			throw new js__$Boot_HaxeError("FAIL: min <= max");
		}
		if(!true) {
			throw new js__$Boot_HaxeError("FAIL: min <= max");
		}
		if(!true) {
			throw new js__$Boot_HaxeError("FAIL: min <= max");
		}
		if(!true) {
			throw new js__$Boot_HaxeError("FAIL: min <= max");
		}
		bitmap.data[x] = ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);
		i += 4;
		++x;
	}
	return bitmap;
};
geometrize_bitmap_Bitmap.prototype = {
	getPixel: function(x,y) {
		return this.data[this.width * y + x];
	}
	,setPixel: function(x,y,color) {
		this.data[this.width * y + x] = color;
	}
	,clone: function() {
		var bitmap = new geometrize_bitmap_Bitmap();
		bitmap.width = this.width;
		bitmap.height = this.height;
		var length = this.data.length;
		var this1 = new Array(length);
		bitmap.data = this1;
		var _g1 = 0;
		var _g = this.data.length;
		while(_g1 < _g) {
			var i = _g1++;
			bitmap.data[i] = this.data[i];
		}
		return bitmap;
	}
	,fill: function(color) {
		var idx = 0;
		while(idx < this.data.length) {
			this.data[idx] = color >>> 24 & 255;
			this.data[idx + 1] = color >>> 16 & 255;
			this.data[idx + 2] = color >>> 8 & 255;
			this.data[idx + 3] = color & 255;
			idx += 4;
		}
	}
	,getBytes: function() {
		var bytes = new haxe_io_Bytes(new ArrayBuffer(this.data.length * 4));
		var i = 0;
		while(i < this.data.length) {
			var idx = i * 4;
			bytes.b[idx] = this.data[i] >>> 24 & 255 & 255;
			bytes.b[idx + 1] = this.data[i] >>> 16 & 255 & 255;
			bytes.b[idx + 2] = this.data[i] >>> 8 & 255 & 255;
			bytes.b[idx + 3] = this.data[i] & 255 & 255;
			++i;
		}
		return bytes;
	}
	,__class__: geometrize_bitmap_Bitmap
};
var geometrize_bitmap__$Rgba_Rgba_$Impl_$ = {};
geometrize_bitmap__$Rgba_Rgba_$Impl_$.__name__ = true;
geometrize_bitmap__$Rgba_Rgba_$Impl_$._new = function(rgba) {
	var this1 = rgba;
	return this1;
};
geometrize_bitmap__$Rgba_Rgba_$Impl_$.create = function(red,green,blue,alpha) {
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	return ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);
};
geometrize_bitmap__$Rgba_Rgba_$Impl_$.add = function(lhs,rhs) {
	var red = (lhs >>> 24 & 255) + (rhs >>> 24 & 255);
	var green = (lhs >>> 16 & 255) + (rhs >>> 16 & 255);
	var blue = (lhs >>> 8 & 255) + (rhs >>> 8 & 255);
	var alpha = (lhs & 255) + (rhs & 255);
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	return ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);
};
geometrize_bitmap__$Rgba_Rgba_$Impl_$.subtract = function(lhs,rhs) {
	var red = (lhs >>> 24 & 255) - (rhs >>> 24 & 255);
	var green = (lhs >>> 16 & 255) - (rhs >>> 16 & 255);
	var blue = (lhs >>> 8 & 255) - (rhs >>> 8 & 255);
	var alpha = (lhs & 255) - (rhs & 255);
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	return ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);
};
geometrize_bitmap__$Rgba_Rgba_$Impl_$.fromInt = function(rgba) {
	return rgba;
};
geometrize_bitmap__$Rgba_Rgba_$Impl_$.get_r = function(this1) {
	return this1 >>> 24 & 255;
};
geometrize_bitmap__$Rgba_Rgba_$Impl_$.get_g = function(this1) {
	return this1 >>> 16 & 255;
};
geometrize_bitmap__$Rgba_Rgba_$Impl_$.get_b = function(this1) {
	return this1 >>> 8 & 255;
};
geometrize_bitmap__$Rgba_Rgba_$Impl_$.get_a = function(this1) {
	return this1 & 255;
};
var geometrize_exporter_SvgExporter = function() { };
geometrize_exporter_SvgExporter.__name__ = true;
geometrize_exporter_SvgExporter["export"] = function(shapes,width,height) {
	var results = geometrize_exporter_SvgExporter.getPrelude();
	results += geometrize_exporter_SvgExporter.getSvgNodeOpen(width,height);
	results += geometrize_exporter_SvgExporter.exportShapes(shapes);
	results += geometrize_exporter_SvgExporter.getSvgNodeClose();
	return results;
};
geometrize_exporter_SvgExporter.exportShapes = function(shapes) {
	var results = "";
	var _g1 = 0;
	var _g = shapes.length;
	while(_g1 < _g) {
		var i = _g1++;
		results += geometrize_exporter_SvgExporter.exportShape(shapes[i]);
		if(i != shapes.length - 1) {
			results += "\n";
		}
	}
	return results;
};
geometrize_exporter_SvgExporter.exportShape = function(shape) {
	return StringTools.replace(shape.shape.getSvgShapeData(),geometrize_exporter_SvgExporter.SVG_STYLE_HOOK,geometrize_exporter_SvgExporter.stylesForShape(shape));
};
geometrize_exporter_SvgExporter.stylesForShape = function(shape) {
	var _g = shape.shape.getType();
	if(_g[1] == 6) {
		return geometrize_exporter_SvgExporter.strokeForColor(shape.color) + " stroke-width=\"1\" fill=\"none\" " + geometrize_exporter_SvgExporter.strokeOpacityForAlpha(shape.color & 255);
	} else {
		return geometrize_exporter_SvgExporter.fillForColor(shape.color) + " " + geometrize_exporter_SvgExporter.fillOpacityForAlpha(shape.color & 255);
	}
};
geometrize_exporter_SvgExporter.rgbForColor = function(color) {
	return "rgb(" + (color >>> 24 & 255) + "," + (color >>> 16 & 255) + "," + (color >>> 8 & 255) + ")";
};
geometrize_exporter_SvgExporter.strokeForColor = function(color) {
	return "stroke=\"" + geometrize_exporter_SvgExporter.rgbForColor(color) + "\"";
};
geometrize_exporter_SvgExporter.fillForColor = function(color) {
	return "fill=\"" + geometrize_exporter_SvgExporter.rgbForColor(color) + "\"";
};
geometrize_exporter_SvgExporter.fillOpacityForAlpha = function(alpha) {
	return "fill-opacity=\"" + alpha / 255.0 + "\"";
};
geometrize_exporter_SvgExporter.strokeOpacityForAlpha = function(alpha) {
	return "stroke-opacity=\"" + alpha / 255.0 + "\"";
};
geometrize_exporter_SvgExporter.getPrelude = function() {
	return "<?xml version=\"1.0\" standalone=\"no\"?>\n";
};
geometrize_exporter_SvgExporter.getSvgNodeOpen = function(width,height) {
	return "<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.2\" baseProfile=\"tiny\" width=\"" + width + "\" height=\"" + height + "\">\n";
};
geometrize_exporter_SvgExporter.getSvgNodeClose = function() {
	return "</svg>";
};
var geometrize_rasterizer_Rasterizer = function() { };
geometrize_rasterizer_Rasterizer.__name__ = true;
geometrize_rasterizer_Rasterizer.drawLines = function(image,c,lines) {
	if(!(image != null)) {
		throw new js__$Boot_HaxeError("FAIL: image != null");
	}
	if(!(lines != null)) {
		throw new js__$Boot_HaxeError("FAIL: lines != null");
	}
	var sr = c >>> 24 & 255;
	sr |= sr << 8;
	sr *= c & 255;
	sr = sr / 255 | 0;
	var sg = c >>> 16 & 255;
	sg |= sg << 8;
	sg *= c & 255;
	sg = sg / 255 | 0;
	var sb = c >>> 8 & 255;
	sb |= sb << 8;
	sb *= c & 255;
	sb = sb / 255 | 0;
	var sa = c & 255;
	sa |= sa << 8;
	var _g = 0;
	while(_g < lines.length) {
		var line = lines[_g];
		++_g;
		var y = line.y;
		var ma = 65535;
		var m = 65535;
		var $as = (m - sa * (ma / m)) * 257;
		var a = $as | 0;
		var _g2 = line.x1;
		var _g1 = line.x2 + 1;
		while(_g2 < _g1) {
			var x = _g2++;
			var d = image.data[image.width * y + x];
			var dr = d >>> 24 & 255;
			var dg = d >>> 16 & 255;
			var db = d >>> 8 & 255;
			var da = d & 255;
			var r = (_$UInt_UInt_$Impl_$.toFloat(dr * a + sr * ma) / _$UInt_UInt_$Impl_$.toFloat(m) | 0) >> 8;
			var g = (_$UInt_UInt_$Impl_$.toFloat(dg * a + sg * ma) / _$UInt_UInt_$Impl_$.toFloat(m) | 0) >> 8;
			var b = (_$UInt_UInt_$Impl_$.toFloat(db * a + sb * ma) / _$UInt_UInt_$Impl_$.toFloat(m) | 0) >> 8;
			var a1 = (_$UInt_UInt_$Impl_$.toFloat(da * a + sa * ma) / _$UInt_UInt_$Impl_$.toFloat(m) | 0) >> 8;
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			image.data[image.width * y + x] = ((r < 0 ? 0 : r > 255 ? 255 : r) << 24) + ((g < 0 ? 0 : g > 255 ? 255 : g) << 16) + ((b < 0 ? 0 : b > 255 ? 255 : b) << 8) + (a1 < 0 ? 0 : a1 > 255 ? 255 : a1);
		}
	}
};
geometrize_rasterizer_Rasterizer.copyLines = function(destination,source,lines) {
	if(!(destination != null)) {
		throw new js__$Boot_HaxeError("FAIL: destination != null");
	}
	if(!(source != null)) {
		throw new js__$Boot_HaxeError("FAIL: source != null");
	}
	if(!(lines != null)) {
		throw new js__$Boot_HaxeError("FAIL: lines != null");
	}
	var _g = 0;
	while(_g < lines.length) {
		var line = lines[_g];
		++_g;
		var y = line.y;
		var _g2 = line.x1;
		var _g1 = line.x2 + 1;
		while(_g2 < _g1) {
			var x = _g2++;
			destination.data[destination.width * y + x] = source.data[source.width * y + x];
		}
	}
};
geometrize_rasterizer_Rasterizer.bresenham = function(x1,y1,x2,y2) {
	var dx = x2 - x1;
	var ix = (dx > 0 ? 1 : 0) - (dx < 0 ? 1 : 0);
	dx = (dx < 0 ? -dx : dx) << 1;
	var dy = y2 - y1;
	var iy = (dy > 0 ? 1 : 0) - (dy < 0 ? 1 : 0);
	dy = (dy < 0 ? -dy : dy) << 1;
	var points = [];
	points.push({ x : x1, y : y1});
	if(dx >= dy) {
		var error = dy - (dx >> 1);
		while(x1 != x2) {
			if(error >= 0 && (error != 0 || ix > 0)) {
				error -= dx;
				y1 += iy;
			}
			error += dy;
			x1 += ix;
			points.push({ x : x1, y : y1});
		}
	} else {
		var error1 = dx - (dy >> 1);
		while(y1 != y2) {
			if(error1 >= 0 && (error1 != 0 || iy > 0)) {
				error1 -= dy;
				x1 += ix;
			}
			error1 += dx;
			y1 += iy;
			points.push({ x : x1, y : y1});
		}
	}
	return points;
};
geometrize_rasterizer_Rasterizer.scanlinesForPolygon = function(points) {
	var lines = [];
	var edges = [];
	var _g1 = 0;
	var _g = points.length;
	while(_g1 < _g) {
		var i = _g1++;
		var p1 = points[i];
		var p2 = i == points.length - 1 ? points[0] : points[i + 1];
		var p1p2 = geometrize_rasterizer_Rasterizer.bresenham(p1.x,p1.y,p2.x,p2.y);
		edges = edges.concat(p1p2);
	}
	var yToXs = new haxe_ds_IntMap();
	var _g2 = 0;
	while(_g2 < edges.length) {
		var point = edges[_g2];
		++_g2;
		var s = yToXs.h[point.y];
		if(s != null) {
			geometrize__$ArraySet_ArraySet_$Impl_$.add(s,point.x);
		} else {
			s = geometrize__$ArraySet_ArraySet_$Impl_$.create();
			geometrize__$ArraySet_ArraySet_$Impl_$.add(s,point.x);
			yToXs.h[point.y] = s;
		}
	}
	var key = yToXs.keys();
	while(key.hasNext()) {
		var key1 = key.next();
		var a = geometrize__$ArraySet_ArraySet_$Impl_$.toArray(yToXs.h[key1]);
		var minMaxElements;
		if(a == null || a.length == 0) {
			minMaxElements = { min : 0, max : 0};
		} else {
			var min = a[0];
			var max = a[0];
			var _g3 = 0;
			while(_g3 < a.length) {
				var value = a[_g3];
				++_g3;
				if(min > value) {
					min = value;
				}
				if(max < value) {
					max = value;
				}
			}
			minMaxElements = { min : min, max : max};
		}
		lines.push(new geometrize_rasterizer_Scanline(key1,minMaxElements.min,minMaxElements.max));
	}
	return lines;
};
var geometrize_rasterizer_Scanline = function(y,x1,x2) {
	this.y = y;
	this.x1 = x1;
	this.x2 = x2;
};
geometrize_rasterizer_Scanline.__name__ = true;
geometrize_rasterizer_Scanline.trim = function(scanlines,w,h) {
	if(!(scanlines != null)) {
		throw new js__$Boot_HaxeError("FAIL: scanlines != null");
	}
	var w1 = w;
	var h1 = h;
	return scanlines.filter(function(a1) {
		return geometrize_rasterizer_Scanline.trimHelper(a1,w1,h1);
	});
};
geometrize_rasterizer_Scanline.trimHelper = function(line,w,h) {
	if(line.y < 0 || line.y >= h || line.x1 >= w || line.x2 < 0) {
		return false;
	}
	var value = line.x1;
	var max = w - 1;
	if(!(0 <= max)) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	line.x1 = value < 0 ? 0 : value > max ? max : value;
	var value1 = line.x2;
	var max1 = w - 1;
	if(!(0 <= max1)) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	line.x2 = value1 < 0 ? 0 : value1 > max1 ? max1 : value1;
	if(line.x1 > line.x2) {
		return false;
	}
	return true;
};
geometrize_rasterizer_Scanline.prototype = {
	__class__: geometrize_rasterizer_Scanline
};
var geometrize_runner_ImageRunner = function(inputImage,backgroundColor) {
	this.model = null;
	this.model = new geometrize_Model(inputImage,backgroundColor);
};
geometrize_runner_ImageRunner.__name__ = true;
geometrize_runner_ImageRunner.prototype = {
	step: function(options) {
		return this.model.step(options.shapeTypes,options.alpha,options.candidateShapesPerStep,options.shapeMutationsPerStep);
	}
	,getImageData: function() {
		if(!(this.model != null)) {
			throw new js__$Boot_HaxeError("FAIL: model != null");
		}
		return this.model.current;
	}
	,__class__: geometrize_runner_ImageRunner
};
var geometrize_runner_ImageRunnerOptions = function(shapeTypes,alpha,candidateShapesPerStep,shapeMutationsPerStep) {
	if(shapeMutationsPerStep == null) {
		shapeMutationsPerStep = 50;
	}
	if(candidateShapesPerStep == null) {
		candidateShapesPerStep = 100;
	}
	if(alpha == null) {
		alpha = 128;
	}
	if(shapeTypes == null) {
		shapeTypes = [geometrize_shape_ShapeType.RECTANGLE];
	}
	this.shapeTypes = shapeTypes;
	this.alpha = alpha;
	this.candidateShapesPerStep = candidateShapesPerStep;
	this.shapeMutationsPerStep = shapeMutationsPerStep;
};
geometrize_runner_ImageRunnerOptions.__name__ = true;
geometrize_runner_ImageRunnerOptions.prototype = {
	__class__: geometrize_runner_ImageRunnerOptions
};
var geometrize_shape_Shape = function() { };
geometrize_shape_Shape.__name__ = true;
geometrize_shape_Shape.prototype = {
	__class__: geometrize_shape_Shape
};
var geometrize_shape_Ellipse = function(xBound,yBound) {
	this.x = Std.random(xBound);
	this.y = Std.random(yBound);
	this.rx = Std.random(32) + 1;
	this.ry = Std.random(32) + 1;
	this.xBound = xBound;
	this.yBound = yBound;
};
geometrize_shape_Ellipse.__name__ = true;
geometrize_shape_Ellipse.__interfaces__ = [geometrize_shape_Shape];
geometrize_shape_Ellipse.prototype = {
	rasterize: function() {
		var lines = [];
		var aspect = this.rx / this.ry;
		var w = this.xBound;
		var h = this.yBound;
		var _g1 = 0;
		var _g = this.ry;
		while(_g1 < _g) {
			var dy = _g1++;
			var y1 = this.y - dy;
			var y2 = this.y + dy;
			if((y1 < 0 || y1 >= h) && (y2 < 0 || y2 >= h)) {
				continue;
			}
			var s = Math.sqrt(this.ry * this.ry - dy * dy) * aspect | 0;
			var x1 = this.x - s;
			var x2 = this.x + s;
			if(x1 < 0) {
				x1 = 0;
			}
			if(x2 >= w) {
				x2 = w - 1;
			}
			if(y1 >= 0 && y1 < h) {
				lines.push(new geometrize_rasterizer_Scanline(y1,x1,x2));
			}
			if(y2 >= 0 && y2 < h && dy > 0) {
				lines.push(new geometrize_rasterizer_Scanline(y2,x1,x2));
			}
		}
		return lines;
	}
	,mutate: function() {
		var r = Std.random(3);
		switch(r) {
		case 0:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value = this.x + (-16 + Math.floor(33 * Math.random()));
			var max = this.xBound - 1;
			if(!(0 <= max)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.x = value < 0 ? 0 : value > max ? max : value;
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value1 = this.y + (-16 + Math.floor(33 * Math.random()));
			var max1 = this.yBound - 1;
			if(!(0 <= max1)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.y = value1 < 0 ? 0 : value1 > max1 ? max1 : value1;
			break;
		case 1:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value2 = this.rx + (-16 + Math.floor(33 * Math.random()));
			var max2 = this.xBound - 1;
			if(!(1 <= max2)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.rx = value2 < 1 ? 1 : value2 > max2 ? max2 : value2;
			break;
		case 2:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value3 = this.ry + (-16 + Math.floor(33 * Math.random()));
			var max3 = this.xBound - 1;
			if(!(1 <= max3)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.ry = value3 < 1 ? 1 : value3 > max3 ? max3 : value3;
			break;
		}
	}
	,clone: function() {
		var ellipse = new geometrize_shape_Ellipse(this.xBound,this.yBound);
		ellipse.x = this.x;
		ellipse.y = this.y;
		ellipse.rx = this.rx;
		ellipse.ry = this.ry;
		return ellipse;
	}
	,getType: function() {
		return geometrize_shape_ShapeType.ELLIPSE;
	}
	,getRawShapeData: function() {
		return [this.x,this.y,this.rx,this.ry];
	}
	,getSvgShapeData: function() {
		return "<ellipse cx=\"" + this.x + "\" cy=\"" + this.y + "\" rx=\"" + this.rx + "\" ry=\"" + this.ry + "\" " + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + " />";
	}
	,__class__: geometrize_shape_Ellipse
};
var geometrize_shape_Circle = function(xBound,yBound) {
	geometrize_shape_Ellipse.call(this,xBound,yBound);
	this.rx = Std.random(32) + 1;
	this.ry = this.rx;
};
geometrize_shape_Circle.__name__ = true;
geometrize_shape_Circle.__super__ = geometrize_shape_Ellipse;
geometrize_shape_Circle.prototype = $extend(geometrize_shape_Ellipse.prototype,{
	mutate: function() {
		var r = Std.random(2);
		switch(r) {
		case 0:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value = this.x + (-16 + Math.floor(33 * Math.random()));
			var max = this.xBound - 1;
			if(!(0 <= max)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.x = value < 0 ? 0 : value > max ? max : value;
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value1 = this.y + (-16 + Math.floor(33 * Math.random()));
			var max1 = this.yBound - 1;
			if(!(0 <= max1)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.y = value1 < 0 ? 0 : value1 > max1 ? max1 : value1;
			break;
		case 1:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value2 = this.rx + (-16 + Math.floor(33 * Math.random()));
			var max2 = this.xBound - 1;
			if(!(1 <= max2)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			var r1 = value2 < 1 ? 1 : value2 > max2 ? max2 : value2;
			this.rx = r1;
			this.ry = r1;
			break;
		}
	}
	,clone: function() {
		var circle = new geometrize_shape_Circle(this.xBound,this.yBound);
		circle.x = this.x;
		circle.y = this.y;
		circle.rx = this.rx;
		circle.ry = this.ry;
		return circle;
	}
	,getType: function() {
		return geometrize_shape_ShapeType.CIRCLE;
	}
	,getRawShapeData: function() {
		return [this.x,this.y,this.rx];
	}
	,getSvgShapeData: function() {
		return "<circle cx=\"" + this.x + "\" cy=\"" + this.y + "\" r=\"" + this.rx + "\" " + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + " />";
	}
	,__class__: geometrize_shape_Circle
});
var geometrize_shape_Line = function(xBound,yBound) {
	this.x1 = Std.random(xBound);
	this.y1 = Std.random(yBound);
	var value = this.x1 + Std.random(32) + 1;
	if(!(0 <= xBound)) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	this.x2 = value < 0 ? 0 : value > xBound ? xBound : value;
	var value1 = this.y1 + Std.random(32) + 1;
	if(!(0 <= yBound)) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	this.y2 = value1 < 0 ? 0 : value1 > yBound ? yBound : value1;
	this.xBound = xBound;
	this.yBound = yBound;
};
geometrize_shape_Line.__name__ = true;
geometrize_shape_Line.__interfaces__ = [geometrize_shape_Shape];
geometrize_shape_Line.prototype = {
	rasterize: function() {
		var lines = [];
		var points = geometrize_rasterizer_Rasterizer.bresenham(this.x1,this.y1,this.x2,this.y2);
		var _g = 0;
		while(_g < points.length) {
			var point = points[_g];
			++_g;
			lines.push(new geometrize_rasterizer_Scanline(point.y,point.x,point.x));
		}
		return geometrize_rasterizer_Scanline.trim(lines,this.xBound,this.yBound);
	}
	,mutate: function() {
		var r = Std.random(4);
		switch(r) {
		case 0:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value = this.x1 + (-16 + Math.floor(33 * Math.random()));
			var max = this.xBound - 1;
			if(!(0 <= max)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.x1 = value < 0 ? 0 : value > max ? max : value;
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value1 = this.y1 + (-16 + Math.floor(33 * Math.random()));
			var max1 = this.yBound - 1;
			if(!(0 <= max1)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.y1 = value1 < 0 ? 0 : value1 > max1 ? max1 : value1;
			break;
		case 1:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value2 = this.x2 + (-16 + Math.floor(33 * Math.random()));
			var max2 = this.xBound - 1;
			if(!(0 <= max2)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.x2 = value2 < 0 ? 0 : value2 > max2 ? max2 : value2;
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value3 = this.y2 + (-16 + Math.floor(33 * Math.random()));
			var max3 = this.yBound - 1;
			if(!(0 <= max3)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.y2 = value3 < 0 ? 0 : value3 > max3 ? max3 : value3;
			break;
		}
	}
	,clone: function() {
		var line = new geometrize_shape_Line(this.xBound,this.yBound);
		line.x1 = this.x1;
		line.y1 = this.y1;
		line.x2 = this.x2;
		line.y2 = this.y2;
		return line;
	}
	,getType: function() {
		return geometrize_shape_ShapeType.LINE;
	}
	,getRawShapeData: function() {
		return [this.x1,this.y1,this.x2,this.y2];
	}
	,getSvgShapeData: function() {
		return "<line x1=\"" + this.x1 + "\" y1=\"" + this.y1 + "\" x2=\"" + this.x2 + "\" y2=\"" + this.y2 + "\" " + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + " />";
	}
	,__class__: geometrize_shape_Line
};
var geometrize_shape_Rectangle = function(xBound,yBound) {
	this.x1 = Std.random(xBound);
	this.y1 = Std.random(yBound);
	var value = this.x1 + Std.random(32) + 1;
	var max = xBound - 1;
	if(!(0 <= max)) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	this.x2 = value < 0 ? 0 : value > max ? max : value;
	var value1 = this.y1 + Std.random(32) + 1;
	var max1 = yBound - 1;
	if(!(0 <= max1)) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	this.y2 = value1 < 0 ? 0 : value1 > max1 ? max1 : value1;
	this.xBound = xBound;
	this.yBound = yBound;
};
geometrize_shape_Rectangle.__name__ = true;
geometrize_shape_Rectangle.__interfaces__ = [geometrize_shape_Shape];
geometrize_shape_Rectangle.prototype = {
	rasterize: function() {
		var lines = [];
		var _g1 = this.y1;
		var _g = this.y2;
		while(_g1 < _g) {
			var y = _g1++;
			if(this.x1 != this.x2) {
				var first = this.x1;
				var second = this.x2;
				var first1 = this.x1;
				var second1 = this.x2;
				lines.push(new geometrize_rasterizer_Scanline(y,first < second ? first : second,first1 > second1 ? first1 : second1));
			}
		}
		return lines;
	}
	,mutate: function() {
		var r = Std.random(2);
		switch(r) {
		case 0:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value = this.x1 + (-16 + Math.floor(33 * Math.random()));
			var max = this.xBound - 1;
			if(!(0 <= max)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.x1 = value < 0 ? 0 : value > max ? max : value;
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value1 = this.y1 + (-16 + Math.floor(33 * Math.random()));
			var max1 = this.yBound - 1;
			if(!(0 <= max1)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.y1 = value1 < 0 ? 0 : value1 > max1 ? max1 : value1;
			break;
		case 1:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value2 = this.x2 + (-16 + Math.floor(33 * Math.random()));
			var max2 = this.xBound - 1;
			if(!(0 <= max2)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.x2 = value2 < 0 ? 0 : value2 > max2 ? max2 : value2;
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value3 = this.y2 + (-16 + Math.floor(33 * Math.random()));
			var max3 = this.yBound - 1;
			if(!(0 <= max3)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.y2 = value3 < 0 ? 0 : value3 > max3 ? max3 : value3;
			break;
		}
	}
	,clone: function() {
		var rectangle = new geometrize_shape_Rectangle(this.xBound,this.yBound);
		rectangle.x1 = this.x1;
		rectangle.y1 = this.y1;
		rectangle.x2 = this.x2;
		rectangle.y2 = this.y2;
		return rectangle;
	}
	,getType: function() {
		return geometrize_shape_ShapeType.RECTANGLE;
	}
	,getRawShapeData: function() {
		var first = this.x1;
		var second = this.x2;
		var first1 = this.y1;
		var second1 = this.y2;
		var first2 = this.x1;
		var second2 = this.x2;
		var first3 = this.y1;
		var second3 = this.y2;
		return [first < second ? first : second,first1 < second1 ? first1 : second1,first2 > second2 ? first2 : second2,first3 > second3 ? first3 : second3];
	}
	,getSvgShapeData: function() {
		var first = this.x1;
		var second = this.x2;
		var first1 = this.y1;
		var second1 = this.y2;
		var first2 = this.x1;
		var second2 = this.x2;
		var first3 = this.x1;
		var second3 = this.x2;
		var first4 = this.y1;
		var second4 = this.y2;
		var first5 = this.y1;
		var second5 = this.y2;
		return "<rect x=\"" + (first < second ? first : second) + "\" y=\"" + (first1 < second1 ? first1 : second1) + "\" width=\"" + ((first2 > second2 ? first2 : second2) - (first3 < second3 ? first3 : second3)) + "\" height=\"" + ((first4 > second4 ? first4 : second4) - (first5 < second5 ? first5 : second5)) + "\" " + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + " />";
	}
	,__class__: geometrize_shape_Rectangle
};
var geometrize_shape_RotatedEllipse = function(xBound,yBound) {
	this.x = Std.random(xBound);
	this.y = Std.random(yBound);
	this.rx = Std.random(32) + 1;
	this.ry = Std.random(32) + 1;
	this.angle = Std.random(360);
	this.xBound = xBound;
	this.yBound = yBound;
};
geometrize_shape_RotatedEllipse.__name__ = true;
geometrize_shape_RotatedEllipse.__interfaces__ = [geometrize_shape_Shape];
geometrize_shape_RotatedEllipse.prototype = {
	rasterize: function() {
		var pointCount = 20;
		var points = [];
		var rads = this.angle * (Math.PI / 180.0);
		var c = Math.cos(rads);
		var s = Math.sin(rads);
		var _g1 = 0;
		var _g = pointCount;
		while(_g1 < _g) {
			var i = _g1++;
			var rot = 360.0 / pointCount * i * (Math.PI / 180.0);
			var crx = this.rx * Math.cos(rot);
			var cry = this.ry * Math.sin(rot);
			var tx = crx * c - cry * s + this.x | 0;
			var ty = crx * s + cry * c + this.y | 0;
			points.push({ x : tx, y : ty});
		}
		return geometrize_rasterizer_Scanline.trim(geometrize_rasterizer_Rasterizer.scanlinesForPolygon(points),this.xBound,this.yBound);
	}
	,mutate: function() {
		var r = Std.random(4);
		switch(r) {
		case 0:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value = this.x + (-16 + Math.floor(33 * Math.random()));
			var max = this.xBound - 1;
			if(!(0 <= max)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.x = value < 0 ? 0 : value > max ? max : value;
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value1 = this.y + (-16 + Math.floor(33 * Math.random()));
			var max1 = this.yBound - 1;
			if(!(0 <= max1)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.y = value1 < 0 ? 0 : value1 > max1 ? max1 : value1;
			break;
		case 1:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value2 = this.rx + (-16 + Math.floor(33 * Math.random()));
			var max2 = this.xBound - 1;
			if(!(1 <= max2)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.rx = value2 < 1 ? 1 : value2 > max2 ? max2 : value2;
			break;
		case 2:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value3 = this.ry + (-16 + Math.floor(33 * Math.random()));
			var max3 = this.xBound - 1;
			if(!(1 <= max3)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.ry = value3 < 1 ? 1 : value3 > max3 ? max3 : value3;
			break;
		case 3:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value4 = this.angle + (-4 + Math.floor(9 * Math.random()));
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.angle = value4 < 0 ? 0 : value4 > 360 ? 360 : value4;
			break;
		}
	}
	,clone: function() {
		var ellipse = new geometrize_shape_RotatedEllipse(this.xBound,this.yBound);
		ellipse.x = this.x;
		ellipse.y = this.y;
		ellipse.rx = this.rx;
		ellipse.ry = this.ry;
		ellipse.angle = this.angle;
		return ellipse;
	}
	,getType: function() {
		return geometrize_shape_ShapeType.ROTATED_ELLIPSE;
	}
	,getRawShapeData: function() {
		return [this.x,this.y,this.rx,this.ry,this.angle];
	}
	,getSvgShapeData: function() {
		var s = "<g transform=\"translate(" + this.x + " " + this.y + ") rotate(" + this.angle + ") scale(" + this.rx + " " + this.ry + ")\">";
		s += "<ellipse cx=\"" + 0 + "\" cy=\"" + 0 + "\" rx=\"" + 1 + "\" ry=\"" + 1 + "\" " + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + " />";
		s += "</g>";
		return s;
	}
	,__class__: geometrize_shape_RotatedEllipse
};
var geometrize_shape_RotatedRectangle = function(xBound,yBound) {
	this.x1 = Std.random(xBound);
	this.y1 = Std.random(yBound);
	var value = this.x1 + Std.random(32) + 1;
	if(!(0 <= xBound)) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	this.x2 = value < 0 ? 0 : value > xBound ? xBound : value;
	var value1 = this.y1 + Std.random(32) + 1;
	if(!(0 <= yBound)) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	this.y2 = value1 < 0 ? 0 : value1 > yBound ? yBound : value1;
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: lower <= upper");
	}
	this.angle = Math.floor(361 * Math.random());
	this.xBound = xBound;
	this.yBound = yBound;
};
geometrize_shape_RotatedRectangle.__name__ = true;
geometrize_shape_RotatedRectangle.__interfaces__ = [geometrize_shape_Shape];
geometrize_shape_RotatedRectangle.prototype = {
	rasterize: function() {
		var first = this.x1;
		var second = this.x2;
		var xm1 = first < second ? first : second;
		var first1 = this.x1;
		var second1 = this.x2;
		var xm2 = first1 > second1 ? first1 : second1;
		var first2 = this.y1;
		var second2 = this.y2;
		var ym1 = first2 < second2 ? first2 : second2;
		var first3 = this.y1;
		var second3 = this.y2;
		var ym2 = first3 > second3 ? first3 : second3;
		var cx = (xm1 + xm2) / 2 | 0;
		var cy = (ym1 + ym2) / 2 | 0;
		var ox1 = xm1 - cx;
		var ox2 = xm2 - cx;
		var oy1 = ym1 - cy;
		var oy2 = ym2 - cy;
		var rads = this.angle * Math.PI / 180.0;
		var c = Math.cos(rads);
		var s = Math.sin(rads);
		var ulx = ox1 * c - oy1 * s + cx | 0;
		var uly = ox1 * s + oy1 * c + cy | 0;
		var blx = ox1 * c - oy2 * s + cx | 0;
		var bly = ox1 * s + oy2 * c + cy | 0;
		var urx = ox2 * c - oy1 * s + cx | 0;
		var ury = ox2 * s + oy1 * c + cy | 0;
		var brx = ox2 * c - oy2 * s + cx | 0;
		var bry = ox2 * s + oy2 * c + cy | 0;
		return geometrize_rasterizer_Scanline.trim(geometrize_rasterizer_Rasterizer.scanlinesForPolygon([{ x : ulx, y : uly},{ x : urx, y : ury},{ x : brx, y : bry},{ x : blx, y : bly}]),this.xBound,this.yBound);
	}
	,mutate: function() {
		var r = Std.random(3);
		switch(r) {
		case 0:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value = this.x1 + (-16 + Math.floor(33 * Math.random()));
			var max = this.xBound - 1;
			if(!(0 <= max)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.x1 = value < 0 ? 0 : value > max ? max : value;
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value1 = this.y1 + (-16 + Math.floor(33 * Math.random()));
			var max1 = this.yBound - 1;
			if(!(0 <= max1)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.y1 = value1 < 0 ? 0 : value1 > max1 ? max1 : value1;
			break;
		case 1:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value2 = this.x2 + (-16 + Math.floor(33 * Math.random()));
			var max2 = this.xBound - 1;
			if(!(0 <= max2)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.x2 = value2 < 0 ? 0 : value2 > max2 ? max2 : value2;
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value3 = this.y2 + (-16 + Math.floor(33 * Math.random()));
			var max3 = this.yBound - 1;
			if(!(0 <= max3)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.y2 = value3 < 0 ? 0 : value3 > max3 ? max3 : value3;
			break;
		case 2:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value4 = this.angle + (-4 + Math.floor(9 * Math.random()));
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.angle = value4 < 0 ? 0 : value4 > 360 ? 360 : value4;
			break;
		}
	}
	,clone: function() {
		var rectangle = new geometrize_shape_RotatedRectangle(this.xBound,this.yBound);
		rectangle.x1 = this.x1;
		rectangle.y1 = this.y1;
		rectangle.x2 = this.x2;
		rectangle.y2 = this.y2;
		rectangle.angle = this.angle;
		return rectangle;
	}
	,getType: function() {
		return geometrize_shape_ShapeType.ROTATED_RECTANGLE;
	}
	,getRawShapeData: function() {
		var first = this.x1;
		var second = this.x2;
		var first1 = this.y1;
		var second1 = this.y2;
		var first2 = this.x1;
		var second2 = this.x2;
		var first3 = this.y1;
		var second3 = this.y2;
		return [first < second ? first : second,first1 < second1 ? first1 : second1,first2 > second2 ? first2 : second2,first3 > second3 ? first3 : second3,this.angle];
	}
	,getSvgShapeData: function() {
		var first = this.x1;
		var second = this.x2;
		var first1 = this.x1;
		var second1 = this.x2;
		var width = (first > second ? first : second) - (first1 < second1 ? first1 : second1);
		var first2 = this.y1;
		var second2 = this.y2;
		var first3 = this.y1;
		var second3 = this.y2;
		var height = (first2 > second2 ? first2 : second2) - (first3 < second3 ? first3 : second3);
		var s = "<g transform=\"translate(" + (this.x1 + width / 2) + " " + (this.y1 + height / 2) + ") rotate(" + this.angle + ") scale(" + width + " " + height + ")\">";
		s += "<rect x=\"" + -0.5 + "\" y=\"" + -0.5 + "\" width=\"" + 1 + "\" height=\"" + 1 + "\" " + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + " />";
		s += "</g>";
		return s;
	}
	,__class__: geometrize_shape_RotatedRectangle
};
var geometrize_shape_ShapeFactory = function() { };
geometrize_shape_ShapeFactory.__name__ = true;
geometrize_shape_ShapeFactory.create = function(type,xBound,yBound) {
	switch(type[1]) {
	case 0:
		return new geometrize_shape_Rectangle(xBound,yBound);
	case 1:
		return new geometrize_shape_RotatedRectangle(xBound,yBound);
	case 2:
		return new geometrize_shape_Triangle(xBound,yBound);
	case 3:
		return new geometrize_shape_Ellipse(xBound,yBound);
	case 4:
		return new geometrize_shape_RotatedEllipse(xBound,yBound);
	case 5:
		return new geometrize_shape_Circle(xBound,yBound);
	case 6:
		return new geometrize_shape_Line(xBound,yBound);
	}
};
geometrize_shape_ShapeFactory.randomShape = function(xBound,yBound) {
	var a = geometrize_shape_ShapeType.__empty_constructs__;
	if(!(a != null && a.length > 0)) {
		throw new js__$Boot_HaxeError("FAIL: a != null && a.length > 0");
	}
	var upper = a.length - 1;
	if(!(0 <= upper)) {
		throw new js__$Boot_HaxeError("FAIL: lower <= upper");
	}
	return geometrize_shape_ShapeFactory.create(a[Math.floor((upper + 1) * Math.random())],xBound,yBound);
};
geometrize_shape_ShapeFactory.randomShapeOf = function(types,xBound,yBound) {
	if(!(types != null && types.length > 0)) {
		throw new js__$Boot_HaxeError("FAIL: a != null && a.length > 0");
	}
	var upper = types.length - 1;
	if(!(0 <= upper)) {
		throw new js__$Boot_HaxeError("FAIL: lower <= upper");
	}
	return geometrize_shape_ShapeFactory.create(types[Math.floor((upper + 1) * Math.random())],xBound,yBound);
};
var geometrize_shape_ShapeType = { __ename__ : true, __constructs__ : ["RECTANGLE","ROTATED_RECTANGLE","TRIANGLE","ELLIPSE","ROTATED_ELLIPSE","CIRCLE","LINE"] };
geometrize_shape_ShapeType.RECTANGLE = ["RECTANGLE",0];
geometrize_shape_ShapeType.RECTANGLE.__enum__ = geometrize_shape_ShapeType;
geometrize_shape_ShapeType.ROTATED_RECTANGLE = ["ROTATED_RECTANGLE",1];
geometrize_shape_ShapeType.ROTATED_RECTANGLE.__enum__ = geometrize_shape_ShapeType;
geometrize_shape_ShapeType.TRIANGLE = ["TRIANGLE",2];
geometrize_shape_ShapeType.TRIANGLE.__enum__ = geometrize_shape_ShapeType;
geometrize_shape_ShapeType.ELLIPSE = ["ELLIPSE",3];
geometrize_shape_ShapeType.ELLIPSE.__enum__ = geometrize_shape_ShapeType;
geometrize_shape_ShapeType.ROTATED_ELLIPSE = ["ROTATED_ELLIPSE",4];
geometrize_shape_ShapeType.ROTATED_ELLIPSE.__enum__ = geometrize_shape_ShapeType;
geometrize_shape_ShapeType.CIRCLE = ["CIRCLE",5];
geometrize_shape_ShapeType.CIRCLE.__enum__ = geometrize_shape_ShapeType;
geometrize_shape_ShapeType.LINE = ["LINE",6];
geometrize_shape_ShapeType.LINE.__enum__ = geometrize_shape_ShapeType;
geometrize_shape_ShapeType.__empty_constructs__ = [geometrize_shape_ShapeType.RECTANGLE,geometrize_shape_ShapeType.ROTATED_RECTANGLE,geometrize_shape_ShapeType.TRIANGLE,geometrize_shape_ShapeType.ELLIPSE,geometrize_shape_ShapeType.ROTATED_ELLIPSE,geometrize_shape_ShapeType.CIRCLE,geometrize_shape_ShapeType.LINE];
var geometrize_shape_Triangle = function(xBound,yBound) {
	this.x1 = Std.random(xBound);
	this.y1 = Std.random(yBound);
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: lower <= upper");
	}
	this.x2 = this.x1 + (-16 + Math.floor(33 * Math.random()));
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: lower <= upper");
	}
	this.y2 = this.y1 + (-16 + Math.floor(33 * Math.random()));
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: lower <= upper");
	}
	this.x3 = this.x1 + (-16 + Math.floor(33 * Math.random()));
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: lower <= upper");
	}
	this.y3 = this.y1 + (-16 + Math.floor(33 * Math.random()));
	this.xBound = xBound;
	this.yBound = yBound;
};
geometrize_shape_Triangle.__name__ = true;
geometrize_shape_Triangle.__interfaces__ = [geometrize_shape_Shape];
geometrize_shape_Triangle.prototype = {
	rasterize: function() {
		return geometrize_rasterizer_Scanline.trim(geometrize_rasterizer_Rasterizer.scanlinesForPolygon([{ x : this.x1, y : this.y1},{ x : this.x2, y : this.y2},{ x : this.x3, y : this.y3}]),this.xBound,this.yBound);
	}
	,mutate: function() {
		var r = Std.random(3);
		switch(r) {
		case 0:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value = this.x1 + (-16 + Math.floor(33 * Math.random()));
			var max = this.xBound - 1;
			if(!(0 <= max)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.x1 = value < 0 ? 0 : value > max ? max : value;
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value1 = this.y1 + (-16 + Math.floor(33 * Math.random()));
			var max1 = this.yBound - 1;
			if(!(0 <= max1)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.y1 = value1 < 0 ? 0 : value1 > max1 ? max1 : value1;
			break;
		case 1:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value2 = this.x2 + (-16 + Math.floor(33 * Math.random()));
			var max2 = this.xBound - 1;
			if(!(0 <= max2)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.x2 = value2 < 0 ? 0 : value2 > max2 ? max2 : value2;
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value3 = this.y2 + (-16 + Math.floor(33 * Math.random()));
			var max3 = this.yBound - 1;
			if(!(0 <= max3)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.y2 = value3 < 0 ? 0 : value3 > max3 ? max3 : value3;
			break;
		case 2:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value4 = this.x3 + (-16 + Math.floor(33 * Math.random()));
			var max4 = this.xBound - 1;
			if(!(0 <= max4)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.x3 = value4 < 0 ? 0 : value4 > max4 ? max4 : value4;
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value5 = this.y3 + (-16 + Math.floor(33 * Math.random()));
			var max5 = this.yBound - 1;
			if(!(0 <= max5)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.y3 = value5 < 0 ? 0 : value5 > max5 ? max5 : value5;
			break;
		}
	}
	,clone: function() {
		var triangle = new geometrize_shape_Triangle(this.xBound,this.yBound);
		triangle.x1 = this.x1;
		triangle.y1 = this.y1;
		triangle.x2 = this.x2;
		triangle.y2 = this.y2;
		triangle.x3 = this.x3;
		triangle.y3 = this.y3;
		return triangle;
	}
	,getType: function() {
		return geometrize_shape_ShapeType.TRIANGLE;
	}
	,getRawShapeData: function() {
		return [this.x1,this.y1,this.x2,this.y2,this.x3,this.y3];
	}
	,getSvgShapeData: function() {
		return "<polygon points=\"" + this.x1 + "," + this.y1 + " " + this.x2 + "," + this.y2 + " " + this.x3 + "," + this.y3 + "\" " + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + "/>";
	}
	,__class__: geometrize_shape_Triangle
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
var haxe_ds_IntMap = function() {
	this.h = { };
};
haxe_ds_IntMap.__name__ = true;
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	keys: function() {
		var a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) {
			a.push(key | 0);
		}
		return HxOverrides.iter(a);
	}
	,__class__: haxe_ds_IntMap
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = true;
haxe_io_Bytes.prototype = {
	__class__: haxe_io_Bytes
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	this.message = String(val);
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
	__class__: js__$Boot_HaxeError
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.getClass = function(o) {
	if((o instanceof Array) && o.__enum__ == null) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o instanceof Array) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i = _g1++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i2 = _g11++;
				str1 += (i2 > 0 ? "," : "") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g1 = 0;
		var _g = intf.length;
		while(_g1 < _g) {
			var i = _g1++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		if((o instanceof Array)) {
			return o.__enum__ == null;
		} else {
			return false;
		}
		break;
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return true;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return (o|0) === o;
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(o instanceof cl) {
					return true;
				}
				if(js_Boot.__interfLoop(js_Boot.getClass(o),cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(o instanceof cl) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ == cl;
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var js_html_compat_ArrayBuffer = function(a) {
	if((a instanceof Array) && a.__enum__ == null) {
		this.a = a;
		this.byteLength = a.length;
	} else {
		var len = a;
		this.a = [];
		var _g1 = 0;
		var _g = len;
		while(_g1 < _g) {
			var i = _g1++;
			this.a[i] = 0;
		}
		this.byteLength = len;
	}
};
js_html_compat_ArrayBuffer.__name__ = true;
js_html_compat_ArrayBuffer.sliceImpl = function(begin,end) {
	var u = new Uint8Array(this,begin,end == null ? null : end - begin);
	var result = new ArrayBuffer(u.byteLength);
	var resultArray = new Uint8Array(result);
	resultArray.set(u);
	return result;
};
js_html_compat_ArrayBuffer.prototype = {
	slice: function(begin,end) {
		return new js_html_compat_ArrayBuffer(this.a.slice(begin,end));
	}
	,__class__: js_html_compat_ArrayBuffer
};
var js_html_compat_Uint8Array = function() { };
js_html_compat_Uint8Array.__name__ = true;
js_html_compat_Uint8Array._new = function(arg1,offset,length) {
	var arr;
	if(typeof(arg1) == "number") {
		arr = [];
		var _g1 = 0;
		var _g = arg1;
		while(_g1 < _g) {
			var i = _g1++;
			arr[i] = 0;
		}
		arr.byteLength = arr.length;
		arr.byteOffset = 0;
		arr.buffer = new js_html_compat_ArrayBuffer(arr);
	} else if(js_Boot.__instanceof(arg1,js_html_compat_ArrayBuffer)) {
		var buffer = arg1;
		if(offset == null) {
			offset = 0;
		}
		if(length == null) {
			length = buffer.byteLength - offset;
		}
		if(offset == 0) {
			arr = buffer.a;
		} else {
			arr = buffer.a.slice(offset,offset + length);
		}
		arr.byteLength = arr.length;
		arr.byteOffset = offset;
		arr.buffer = buffer;
	} else if((arg1 instanceof Array) && arg1.__enum__ == null) {
		arr = arg1.slice();
		arr.byteLength = arr.length;
		arr.byteOffset = 0;
		arr.buffer = new js_html_compat_ArrayBuffer(arr);
	} else {
		throw new js__$Boot_HaxeError("TODO " + Std.string(arg1));
	}
	arr.subarray = js_html_compat_Uint8Array._subarray;
	arr.set = js_html_compat_Uint8Array._set;
	return arr;
};
js_html_compat_Uint8Array._set = function(arg,offset) {
	if(js_Boot.__instanceof(arg.buffer,js_html_compat_ArrayBuffer)) {
		var a = arg;
		if(arg.byteLength + offset > this.byteLength) {
			throw new js__$Boot_HaxeError("set() outside of range");
		}
		var _g1 = 0;
		var _g = arg.byteLength;
		while(_g1 < _g) {
			var i = _g1++;
			this[i + offset] = a[i];
		}
	} else if((arg instanceof Array) && arg.__enum__ == null) {
		var a1 = arg;
		if(a1.length + offset > this.byteLength) {
			throw new js__$Boot_HaxeError("set() outside of range");
		}
		var _g11 = 0;
		var _g2 = a1.length;
		while(_g11 < _g2) {
			var i1 = _g11++;
			this[i1 + offset] = a1[i1];
		}
	} else {
		throw new js__$Boot_HaxeError("TODO");
	}
};
js_html_compat_Uint8Array._subarray = function(start,end) {
	var a = js_html_compat_Uint8Array._new(this.slice(start,end));
	a.byteOffset = start;
	return a;
};
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = function(){ return f.method.apply(f.scope, arguments); }; f.scope = o; f.method = m; o.hx__closures__[m.__id__] = f; } return f; }
String.prototype.__class__ = String;
String.__name__ = true;
Array.__name__ = true;
var Int = { __name__ : ["Int"]};
var Dynamic = { __name__ : ["Dynamic"]};
var Float = Number;
Float.__name__ = ["Float"];
var Bool = Boolean;
Bool.__ename__ = ["Bool"];
var Class = { __name__ : ["Class"]};
var Enum = { };
var ArrayBuffer = $global.ArrayBuffer || js_html_compat_ArrayBuffer;
if(ArrayBuffer.prototype.slice == null) {
	ArrayBuffer.prototype.slice = js_html_compat_ArrayBuffer.sliceImpl;
}
var Uint8Array = $global.Uint8Array || js_html_compat_Uint8Array._new;
ID.header = "header";
ID.geometrizehaxelogo = "geometrizehaxelogo";
ID.accordion = "accordion";
ID.shapeopacity = "shapeopacity";
ID.randomshapesperstep = "randomshapesperstep";
ID.shapemutationsperstep = "shapemutationsperstep";
ID.rectangles = "rectangles";
ID.rotatedrectangles = "rotatedrectangles";
ID.triangles = "triangles";
ID.ellipses = "ellipses";
ID.rotatedellipses = "rotatedellipses";
ID.circles = "circles";
ID.lines = "lines";
ID.svgoutput = "svgoutput";
ID.eventlog = "eventlog";
ID.currentcanvascontainer = "currentcanvascontainer";
ID.currentimagecanvas = "currentimagecanvas";
ID.currentsvgcontainer = "currentsvgcontainer";
ID.controls = "controls";
ID.runpausebutton = "runpausebutton";
ID.stepbutton = "stepbutton";
ID.openimageinput = "openimageinput";
ID.openimagebutton = "openimagebutton";
ID.resetbutton = "resetbutton";
ID.saveoptions = "saveoptions";
ID.saveimagebutton = "saveimagebutton";
ID.savesvgbutton = "savesvgbutton";
ID.defaultimage = "defaultimage";
Main.WEBSITE_URL = "http://www.samcodes.co.uk/project/geometrize-haxe-web/";
Main.runPauseButton = window.document.getElementById("runpausebutton");
Main.stepButton = window.document.getElementById("stepbutton");
Main.openImageButton = window.document.getElementById("openimagebutton");
Main.openImageFileInput = window.document.getElementById("openimageinput");
Main.resetButton = window.document.getElementById("resetbutton");
Main.saveImageButton = window.document.getElementById("saveimagebutton");
Main.saveSvgButton = window.document.getElementById("savesvgbutton");
Main.rectanglesCheckbox = window.document.getElementById("rectangles");
Main.rotatedRectanglesCheckbox = window.document.getElementById("rotatedrectangles");
Main.trianglesCheckbox = window.document.getElementById("triangles");
Main.ellipsesCheckbox = window.document.getElementById("ellipses");
Main.rotatedEllipsesCheckbox = window.document.getElementById("rotatedellipses");
Main.circlesCheckbox = window.document.getElementById("circles");
Main.linesCheckbox = window.document.getElementById("lines");
Main.shapeOpacitySlider = window.document.getElementById("shapeopacity");
Main.randomShapesPerStepSlider = window.document.getElementById("randomshapesperstep");
Main.shapeMutationsPerStepSlider = window.document.getElementById("shapemutationsperstep");
Main.currentImageCanvas = window.document.getElementById("currentimagecanvas");
Main.logoImageElement = window.document.getElementById("geometrizehaxelogo");
Main.seagullImageElement = window.document.getElementById("defaultimage");
Main.currentSvgContainer = window.document.getElementById("currentsvgcontainer");
Main.eventLogElement = window.document.getElementById("eventlog");
Main.svgTextElement = window.document.getElementById("svgoutput");
geometrize_exporter_SvgExporter.SVG_STYLE_HOOK = "::svg_style_hook::";
js_Boot.__toStr = ({ }).toString;
js_html_compat_Uint8Array.BYTES_PER_ELEMENT = 1;
Main.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);

//# sourceMappingURL=geometrize.js.map